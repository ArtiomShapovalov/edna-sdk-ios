// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target x86_64-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Threads
import CommonCrypto
import CoreData
import Foundation
import Network
import Swift
import SystemConfiguration
@_exported import Threads
import UIKit
import WebKit
import _Concurrency
import os.log
import os
import zlib
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ThematicBreak : BaseNode {
  @objc deinit
}
extension ThematicBreak : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : Server, ConnectionDelegate {
  public var onEvent: ((ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
  public func didReceive(event: ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate, TransportEventClient {
  public var onEvent: ((ConnectionEvent) -> Swift.Void)?
  weak public var delegate: ConnectionDelegate?
  public func write(data: Foundation.Data, opcode: FrameOpCode)
  public func connectionChanged(state: ConnectionState)
  public func didReceive(event: HTTPEvent)
  public func frameProcessed(event: FrameEvent)
  public func didForm(event: FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: ErrorType, b: ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: ((WebSocketError?) -> ())?)
  func write(stringData: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  func write(data: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  func write(ping: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  func write(pong: Foundation.Data, completion: ((WebSocketError?) -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: WebSocketEvent, client: WebSocketClient)
}
open class WebSocket : WebSocketClient, EngineDelegate {
  weak public var delegate: WebSocketDelegate?
  public var onEvent: ((WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set(newValue)
  }
  public init(request: Foundation.URLRequest, engine: Engine)
  public convenience init(request: Foundation.URLRequest, certPinner: CertificatePinning? = FoundationSecurity(), compressionHandler: CompressionHandler? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  public func write(string: Swift.String, completion: ((WebSocketError?) -> ())?)
  public func write(stringData: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  public func write(ping: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  public func write(pong: Foundation.Data, completion: ((WebSocketError?) -> ())?)
  public func didReceive(event: WebSocketEvent)
  @objc deinit
}
public class AttributedStringVisitor {
  public init(styler: Styler, options: DownOptions = .default)
  @objc deinit
}
extension AttributedStringVisitor : Visitor {
  public typealias Result = Foundation.NSMutableAttributedString
  public func visit(document node: Document) -> Foundation.NSMutableAttributedString
  public func visit(blockQuote node: BlockQuote) -> Foundation.NSMutableAttributedString
  public func visit(list node: List) -> Foundation.NSMutableAttributedString
  public func visit(item node: Item) -> Foundation.NSMutableAttributedString
  public func visit(codeBlock node: CodeBlock) -> Foundation.NSMutableAttributedString
  public func visit(htmlBlock node: HtmlBlock) -> Foundation.NSMutableAttributedString
  public func visit(customBlock node: CustomBlock) -> Foundation.NSMutableAttributedString
  public func visit(paragraph node: Paragraph) -> Foundation.NSMutableAttributedString
  public func visit(heading node: Heading) -> Foundation.NSMutableAttributedString
  public func visit(thematicBreak node: ThematicBreak) -> Foundation.NSMutableAttributedString
  public func visit(text node: Text) -> Foundation.NSMutableAttributedString
  public func visit(softBreak node: SoftBreak) -> Foundation.NSMutableAttributedString
  public func visit(lineBreak node: LineBreak) -> Foundation.NSMutableAttributedString
  public func visit(code node: Code) -> Foundation.NSMutableAttributedString
  public func visit(htmlInline node: HtmlInline) -> Foundation.NSMutableAttributedString
  public func visit(customInline node: CustomInline) -> Foundation.NSMutableAttributedString
  public func visit(emphasis node: Emphasis) -> Foundation.NSMutableAttributedString
  public func visit(strong node: Strong) -> Foundation.NSMutableAttributedString
  public func visit(link node: Link) -> Foundation.NSMutableAttributedString
  public func visit(image node: Image) -> Foundation.NSMutableAttributedString
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: WebSocketEvent)
}
public protocol Engine {
  func register(delegate: EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: FrameOpCode, completion: ((WebSocketError?) -> ())?)
  func write(string: Swift.String, completion: ((WebSocketError?) -> ())?)
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class List : BaseNode {
  public var listType: List.ListType {
    get
    set(value)
  }
  public var numberOfItems: Swift.Int {
    get
    set(value)
  }
  @objc deinit
}
extension List {
  public enum ListType : Swift.CustomDebugStringConvertible {
    case bullet
    case ordered(start: Swift.Int)
    public var debugDescription: Swift.String {
      get
    }
  }
}
extension List : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc @objcMembers public class LocalizationConfig : ObjectiveC.NSObject {
  @objc final public let bundle: Foundation.Bundle
  @objc final public let tableName: Swift.String
  @objc public init(bundle: Foundation.Bundle, tableName: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc final public class OGDataProvider : ObjectiveC.NSObject {
  @objc(sharedInstance) public static var shared: OGDataProvider
  @objc final public var cacheManager: OGDataCacheManagerProtocol {
    @objc get
    @objc set(value)
  }
  @objc final public var updateInterval: Foundation.TimeInterval {
    @objc get
    @objc set(newValue)
  }
  @discardableResult
  @objc final public func fetchOGData(withURLString urlString: Swift.String, completion: ((OpenGraphData, Swift.Error?) -> Swift.Void)? = nil) -> Task
  @discardableResult
  @nonobjc final public func fetchOGData(urlString: Swift.String, completion: ((OpenGraph.Data, Swift.Error?) -> Swift.Void)? = nil) -> Task
  @objc final public func deleteOGData(urlString: Swift.String, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  @objc final public func deleteOGData(_ ogData: OpenGraphData, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  @nonobjc final public func deleteOGData(_ ogData: OpenGraph.Data, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  @objc final public func cancelLoading(_ task: Task, shouldContinueDownloading: Swift.Bool)
  @objc deinit
}
public struct CodeBlockOptions {
  public var containerInset: CoreGraphics.CGFloat
  public init(containerInset: CoreGraphics.CGFloat = 8)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CustomBlock : BaseNode {
  public var literal: Swift.String? {
    get
  }
  @objc deinit
}
extension CustomBlock : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  public func toHTML(_ options: DownOptions = .default) throws -> Swift.String
}
public protocol DownGroffRenderable : DownRenderable {
  func toGroff(_ options: DownOptions, width: Swift.Int32) throws -> Swift.String
}
extension DownGroffRenderable {
  public func toGroff(_ options: DownOptions = .default, width: Swift.Int32 = 0) throws -> Swift.String
}
public struct DownGroffRenderer {
  public static func astToGroff(_ ast: Swift.UnsafeMutablePointer<cmark_node>, options: DownOptions = .default, width: Swift.Int32 = 0) throws -> Swift.String
}
public enum OpenGraph {
}
public struct Down : DownASTRenderable, DownHTMLRenderable, DownXMLRenderable, DownLaTeXRenderable, DownGroffRenderable, DownCommonMarkRenderable {
  public var markdownString: Swift.String
  public init(markdownString: Swift.String)
}
extension Down : DownAttributedStringRenderable {
}
public class DebugVisitor : Visitor {
  public init()
  public typealias Result = Swift.String
  public func visit(document node: Document) -> Swift.String
  public func visit(blockQuote node: BlockQuote) -> Swift.String
  public func visit(list node: List) -> Swift.String
  public func visit(item node: Item) -> Swift.String
  public func visit(codeBlock node: CodeBlock) -> Swift.String
  public func visit(htmlBlock node: HtmlBlock) -> Swift.String
  public func visit(customBlock node: CustomBlock) -> Swift.String
  public func visit(paragraph node: Paragraph) -> Swift.String
  public func visit(heading node: Heading) -> Swift.String
  public func visit(thematicBreak node: ThematicBreak) -> Swift.String
  public func visit(text node: Text) -> Swift.String
  public func visit(softBreak node: SoftBreak) -> Swift.String
  public func visit(lineBreak node: LineBreak) -> Swift.String
  public func visit(code node: Code) -> Swift.String
  public func visit(htmlInline node: HtmlInline) -> Swift.String
  public func visit(customInline node: CustomInline) -> Swift.String
  public func visit(emphasis node: Emphasis) -> Swift.String
  public func visit(strong node: Strong) -> Swift.String
  public func visit(link node: Link) -> Swift.String
  public func visit(image node: Image) -> Swift.String
  @objc deinit
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: ServerEvent)
}
public enum ServerEvent {
  case connected(Connection, [Swift.String : Swift.String])
  case disconnected(Connection, Swift.String, Swift.UInt16)
  case text(Connection, Swift.String)
  case binary(Connection, Foundation.Data)
  case pong(Connection, Foundation.Data?)
  case ping(Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: TCPTransportError, b: TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc deinit
}
public struct ThematicBreakOptions {
  public var thickness: CoreGraphics.CGFloat
  public var indentation: CoreGraphics.CGFloat
  public init(thickness: CoreGraphics.CGFloat = 1, indentation: CoreGraphics.CGFloat = 0)
}
public protocol Visitor {
  associatedtype Result
  func visit(document node: Document) -> Self.Result
  func visit(blockQuote node: BlockQuote) -> Self.Result
  func visit(list node: List) -> Self.Result
  func visit(item node: Item) -> Self.Result
  func visit(codeBlock node: CodeBlock) -> Self.Result
  func visit(htmlBlock node: HtmlBlock) -> Self.Result
  func visit(customBlock node: CustomBlock) -> Self.Result
  func visit(paragraph node: Paragraph) -> Self.Result
  func visit(heading node: Heading) -> Self.Result
  func visit(thematicBreak node: ThematicBreak) -> Self.Result
  func visit(text node: Text) -> Self.Result
  func visit(softBreak node: SoftBreak) -> Self.Result
  func visit(lineBreak node: LineBreak) -> Self.Result
  func visit(code node: Code) -> Self.Result
  func visit(htmlInline node: HtmlInline) -> Self.Result
  func visit(customInline node: CustomInline) -> Self.Result
  func visit(emphasis node: Emphasis) -> Self.Result
  func visit(strong node: Strong) -> Self.Result
  func visit(link node: Link) -> Self.Result
  func visit(image node: Image) -> Self.Result
  func visitChildren(of node: Node) -> [Self.Result]
}
extension Visitor {
  public func visitChildren(of node: Node) -> [Self.Result]
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Link : BaseNode {
  public var title: Swift.String? {
    get
  }
  public var url: Swift.String? {
    get
  }
  @objc deinit
}
extension Link : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SoftBreak : BaseNode {
  @objc deinit
}
extension SoftBreak : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class OpenGraphData : ObjectiveC.NSObject {
  @objc final public let imageUrl: Foundation.URL?
  @objc final public let pageDescription: Swift.String?
  @objc final public let pageTitle: Swift.String?
  @objc final public let pageType: Swift.String?
  @objc final public let siteName: Swift.String?
  @objc final public let sourceUrl: Foundation.URL?
  @objc final public let url: Foundation.URL?
  @objc deinit
}
public protocol DownLaTeXRenderable : DownRenderable {
  func toLaTeX(_ options: DownOptions, width: Swift.Int32) throws -> Swift.String
}
extension DownLaTeXRenderable {
  public func toLaTeX(_ options: DownOptions = .default, width: Swift.Int32 = 0) throws -> Swift.String
}
public struct DownLaTeXRenderer {
  public static func astToLaTeX(_ ast: Swift.UnsafeMutablePointer<cmark_node>, options: DownOptions = .default, width: Swift.Int32 = 0) throws -> Swift.String
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Item : BaseNode {
  @objc deinit
}
extension Item : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc final public class OGImageProvider : ObjectiveC.NSObject {
  @objc(sharedInstance) public static var shared: OGImageProvider
  @objc final public func loadImage(withURLString urlString: Swift.String, completion: ((UIKit.UIImage?, Swift.Error?) -> Swift.Void)? = nil) -> Task?
  @nonobjc final public func loadImage(urlString: Swift.String, completion: ((Result<UIKit.UIImage>) -> Swift.Void)? = nil) -> Task?
  @objc final public func clearMemoryCache()
  @objc final public func clearAllCache()
  @objc final public func cancelLoading(_ task: Task, shouldContinueDownloading: Swift.Bool)
  @objc deinit
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: FoundationTransportError, b: FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CustomInline : BaseNode {
  public var literal: Swift.String? {
    get
  }
  @objc deinit
}
extension CustomInline : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CodeBlock : BaseNode {
  public var literal: Swift.String? {
    get
  }
  public var fenceInfo: Swift.String? {
    get
  }
  @objc deinit
}
extension CodeBlock : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(Frame)
  case error(Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: FramerEventClient)
  func createWriteFrame(opcode: FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: FramerEventClient)
  public func createWriteFrame(opcode: FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : MyWSArrayType {
}
extension Swift.Array where Element : Swift.UnsignedInteger, Element : MyWSArrayType {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
@_inheritsConvenienceInitializers @objc final public class OGDataNoCacheManager : ObjectiveC.NSObject, OGDataCacheManagerProtocol {
  @objc final public var updateInterval: Foundation.TimeInterval
  @objc override dynamic public init()
  @objc final public func fetchOrInsertOGCacheData(url: Swift.String, completion: @escaping (OGCacheData) -> ())
  @objc final public func fetchOGCacheData(url: Swift.String, completion: @escaping (OGCacheData?) -> ())
  @objc final public func updateIfNeeded(cache: OGCacheData)
  @objc final public func deleteOGCacheDate(cache: OGCacheData, completion: ((Swift.Error?) -> Swift.Void)?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class TransportMessagesParser : ObjectiveC.NSObject {
  @objc public class func getQuickRepliesFromDict(_ dict: Swift.Dictionary<Swift.String, Any>) -> Swift.Array<QuickReply>?
  @objc public class func getAttrString(fromMarkdown string: Swift.String, withAttributes attributes: THRAttributes, isOutgoing: Swift.Bool) -> Foundation.NSAttributedString
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Strong : BaseNode {
  @objc deinit
}
extension Strong : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : HTTPServerHandler {
  public func register(delegate: HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LineBreak : BaseNode {
  @objc deinit
}
extension LineBreak : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BlockQuote : BaseNode {
  @objc deinit
}
extension BlockQuote : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed(Swift.Error?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: CertificatePinning?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public protocol DownASTRenderable : DownRenderable {
  func toAST(_ options: DownOptions) throws -> Swift.UnsafeMutablePointer<cmark_node>
}
extension DownASTRenderable {
  public func toAST(_ options: DownOptions = .default) throws -> Swift.UnsafeMutablePointer<cmark_node>
}
public struct DownASTRenderer {
  public static func stringToAST(_ string: Swift.String, options: DownOptions = .default) throws -> Swift.UnsafeMutablePointer<cmark_node>
}
public enum WebSocketError {
  case unknownError
  case networkError(Swift.String)
  case compressionError(Swift.String)
  case securityError(Swift.String)
  case protocolError(Swift.String)
  case serverError(Swift.String)
  case anyError(Swift.Error?)
}
public class ListItemParagraphStyler {
  public var indentation: CoreGraphics.CGFloat {
    get
  }
  public var trailingParagraphStyle: UIKit.NSParagraphStyle {
    get
  }
  public init(options: ListItemOptions, prefixFont: DownFont)
  public func leadingParagraphStyle(prefixWidth: CoreGraphics.CGFloat) -> UIKit.NSParagraphStyle
  @objc deinit
}
public protocol DownHTMLRenderable : DownRenderable {
  func toHTML(_ options: DownOptions) throws -> Swift.String
}
extension DownHTMLRenderable {
  public func toHTML(_ options: DownOptions = .default) throws -> Swift.String
}
public struct DownHTMLRenderer {
  public static func astToHTML(_ ast: Swift.UnsafeMutablePointer<cmark_node>, options: DownOptions = .default) throws -> Swift.String
}
@_inheritsConvenienceInitializers @objc public class ThreadsURLSessionDelegate : ObjectiveC.NSObject, Foundation.URLSessionDelegate {
  @objc public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc public class func getPinnedCertificates() -> Swift.Array<Foundation.NSData>
  @objc override dynamic public init()
  @objc deinit
}
public struct DownStylerConfiguration {
  public var fonts: FontCollection
  public var colors: ColorCollection
  public var paragraphStyles: ParagraphStyleCollection
  public var listItemOptions: ListItemOptions
  public var quoteStripeOptions: QuoteStripeOptions
  public var thematicBreakOptions: ThematicBreakOptions
  public var codeBlockOptions: CodeBlockOptions
  public init(fonts: FontCollection = StaticFontCollection(), colors: ColorCollection = StaticColorCollection(), paragraphStyles: ParagraphStyleCollection = StaticParagraphStyleCollection(), listItemOptions: ListItemOptions = ListItemOptions(), quoteStripeOptions: QuoteStripeOptions = QuoteStripeOptions(), thematicBreakOptions: ThematicBreakOptions = ThematicBreakOptions(), codeBlockOptions: CodeBlockOptions = CodeBlockOptions())
}
extension OpenGraph {
  public struct Data {
    public var imageUrl: Foundation.URL? {
      get
    }
    public var pageDescription: Swift.String? {
      get
    }
    public var pageTitle: Swift.String? {
      get
    }
    public var pageType: Swift.String? {
      get
    }
    public var siteName: Swift.String? {
      get
    }
    public var sourceUrl: Foundation.URL? {
      get
    }
    public var url: Foundation.URL? {
      get
    }
  }
}
extension OpenGraph.Data : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = OpenGraphData
  public func _bridgeToObjectiveC() -> OpenGraphData
  public static func _forceBridgeFromObjectiveC(_ source: OpenGraphData, result: inout OpenGraph.Data?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: OpenGraphData, result: inout OpenGraph.Data?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: OpenGraphData?) -> OpenGraph.Data
}
public enum DownErrors : Swift.Error {
  case markdownToASTError
  case astRenderingError
  case htmlDataConversionError
  public static func == (a: DownErrors, b: DownErrors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class WSEngine : Engine, TransportEventClient, FramerEventClient, FrameCollectorDelegate, HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: Transport, certPinner: CertificatePinning? = nil, headerValidator: HeaderValidator = FoundationSecurity(), httpHandler: HTTPHandler = FoundationHTTPHandler(), framer: Framer = WSFramer(), compressionHandler: CompressionHandler? = nil)
  public func register(delegate: EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: ((WebSocketError?) -> ())?)
  public func write(data: Foundation.Data, opcode: FrameOpCode, completion: ((WebSocketError?) -> ())?)
  public func connectionChanged(state: ConnectionState)
  public func didReceiveHTTP(event: HTTPEvent)
  public func frameProcessed(event: FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: FrameCollector.Event)
  @objc deinit
}
public typealias DownFont = UIKit.UIFont
public protocol FontCollection {
  var heading1: DownFont { get set }
  var heading2: DownFont { get set }
  var heading3: DownFont { get set }
  var heading4: DownFont { get set }
  var heading5: DownFont { get set }
  var heading6: DownFont { get set }
  var body: DownFont { get set }
  var code: DownFont { get set }
  var listItemPrefix: DownFont { get set }
}
public struct StaticFontCollection : FontCollection {
  public var heading1: DownFont
  public var heading2: DownFont
  public var heading3: DownFont
  public var heading4: DownFont
  public var heading5: DownFont
  public var heading6: DownFont
  public var body: DownFont
  public var code: DownFont
  public var listItemPrefix: DownFont
  public init(heading1: DownFont = .boldSystemFont(ofSize: 28), heading2: DownFont = .boldSystemFont(ofSize: 24), heading3: DownFont = .boldSystemFont(ofSize: 20), heading4: DownFont = .boldSystemFont(ofSize: 20), heading5: DownFont = .boldSystemFont(ofSize: 20), heading6: DownFont = .boldSystemFont(ofSize: 20), body: DownFont = .systemFont(ofSize: 17), code: DownFont = DownFont(name: "menlo", size: 17) ?? .systemFont(ofSize: 17), listItemPrefix: DownFont = DownFont.monospacedDigitSystemFont(ofSize: 17, weight: .regular))
}
public class FoundationHTTPHandler : HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: HTTPHandlerDelegate)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc final public class OpenGraphDataDownloader : ObjectiveC.NSObject {
  @objc(sharedInstance) public static var shared: OpenGraphDataDownloader
  @discardableResult
  @objc final public func fetchOGData(withURLString urlString: Swift.String, completion: ((OpenGraphData?, Swift.Error?) -> Swift.Void)? = nil) -> Task
  @discardableResult
  @nonobjc final public func fetchOGData(urlString: Swift.String, completion: ((OpenGraphDataDownloader.Result) -> Swift.Void)? = nil) -> Task
  @objc final public func cancelLoading(_ task: Task, shouldContinueDownloading: Swift.Bool)
  @objc deinit
}
extension OpenGraphDataDownloader {
  public enum Error : Swift.Error {
    case createURLFailed(Swift.String)
    case createYoutubeRequestFailed(Swift.String)
  }
  public enum Result {
    case success(data: OpenGraph.Data, isExpired: Swift.Bool)
    case failure(error: Swift.Error, isExpired: Swift.Bool)
  }
}
extension OpenGraphDataDownloader.Result {
  public var isExpired: Swift.Bool {
    get
  }
  public var data: OpenGraph.Data? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
public typealias DownViewClosure = () -> ()
@objc @_Concurrency.MainActor(unsafe) open class DownView : WebKit.WKWebView {
  @_Concurrency.MainActor(unsafe) public init(frame: CoreGraphics.CGRect, markdownString: Swift.String, openLinksInBrowser: Swift.Bool = true, templateBundle: Foundation.Bundle? = nil, writableBundle: Swift.Bool = false, configuration: WebKit.WKWebViewConfiguration? = nil, options: DownOptions = .default, didLoadSuccessfully: DownViewClosure? = nil) throws
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func update(markdownString: Swift.String, options: DownOptions? = nil, didLoadSuccessfully: DownViewClosure? = nil) throws
  @objc deinit
}
extension DownView : WebKit.WKNavigationDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers public class ReachabilityObjC : ObjectiveC.NSObject {
  @objc public static var shared: ReachabilityObjC
  @objc public static func startNotifying(_ listener: @escaping (ReachabilityObjC) -> ())
  @objc public static func startNotifying()
  @objc public static func stopNotifying()
  @objc public static func whenReachable(_ reachable: @escaping (ReachabilityObjC) -> ())
  @objc public static func whenUnreachable(_ unreachable: @escaping (ReachabilityObjC) -> ())
  @objc public static func isConnected() -> Swift.Bool
  @objc public func isConnected() -> Swift.Bool
  @objc public func getConnection() -> ReachabilityObjC.Connection
  @objc public enum Connection : Swift.Int, Swift.RawRepresentable {
    case unavailable
    case wifi
    case cellular
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Connection1 : Swift.CustomStringConvertible {
    @available(*, deprecated, renamed: "unavailable")
    case none
    case unavailable
    case wifi
    case cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: ReachabilityObjC.Connection1, b: ReachabilityObjC.Connection1) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class SocketSettings : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var resendIntervalSec: Swift.Double
  @objc public var resendPingIntervalSec: Swift.Double
  @objc public var connectTimeoutSec: Swift.Double
  @objc public var readTimeoutSec: Swift.Double
  @objc public var writeTimeoutSec: Swift.Double
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class HttpSettings : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var connectTimeoutSec: Swift.Double
  @objc public var downloadTimeoutSec: Swift.Double
  @objc public var uploadTimeoutSec: Swift.Double
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class THRRequestConfigs : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var socket: SocketSettings
  @objc public var http: HttpSettings
  @objc deinit
}
@objc public protocol QuickReplyCellDelegate {
  @objc func didSelectQuickReply(_ quickReply: QuickReply)
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor(unsafe) public class QuickReplyCell : UIKit.UICollectionViewCell {
  @objc @_Concurrency.MainActor(unsafe) public class var sizingCell: QuickReplyCell! {
    @objc get
  }
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var cellWidth: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var actionButton: UIKit.UIButton!
  @objc @_Concurrency.MainActor(unsafe) public class func cellIdentifier() -> Swift.String
  @objc @_Concurrency.MainActor(unsafe) public class func nib() -> UIKit.UINib
  @objc override dynamic public func awakeFromNib()
  @objc @_Concurrency.MainActor(unsafe) public func configure(quickReply: QuickReply, delegate: QuickReplyCellDelegate)
  @objc @_Concurrency.MainActor(unsafe) public func setWidth(_ width: CoreGraphics.CGFloat)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func prepareForReuse()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias TextView = UIKit.UITextView
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class DownTextView : TextView {
  @_Concurrency.MainActor(unsafe) open var styler: Styler
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var text: Swift.String! {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set(value)
  }
  @_Concurrency.MainActor(unsafe) public convenience init(frame: CoreGraphics.CGRect, styler: Styler = DownStyler())
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func render() throws
  @objc deinit
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> URLParts?
}
public typealias DownColor = UIKit.UIColor
public protocol ColorCollection {
  var heading1: DownColor { get set }
  var heading2: DownColor { get set }
  var heading3: DownColor { get set }
  var heading4: DownColor { get set }
  var heading5: DownColor { get set }
  var heading6: DownColor { get set }
  var body: DownColor { get set }
  var code: DownColor { get set }
  var link: DownColor { get set }
  var quote: DownColor { get set }
  var quoteStripe: DownColor { get set }
  var thematicBreak: DownColor { get set }
  var listItemPrefix: DownColor { get set }
  var codeBlockBackground: DownColor { get set }
}
public struct StaticColorCollection : ColorCollection {
  public var heading1: DownColor
  public var heading2: DownColor
  public var heading3: DownColor
  public var heading4: DownColor
  public var heading5: DownColor
  public var heading6: DownColor
  public var body: DownColor
  public var code: DownColor
  public var link: DownColor
  public var quote: DownColor
  public var quoteStripe: DownColor
  public var thematicBreak: DownColor
  public var listItemPrefix: DownColor
  public var codeBlockBackground: DownColor
  public init(heading1: DownColor = .black, heading2: DownColor = .black, heading3: DownColor = .black, heading4: DownColor = .black, heading5: DownColor = .black, heading6: DownColor = .black, body: DownColor = .black, code: DownColor = .black, link: DownColor = .blue, quote: DownColor = .darkGray, quoteStripe: DownColor = .darkGray, thematicBreak: DownColor = .init(white: 0.9, alpha: 1), listItemPrefix: DownColor = .lightGray, codeBlockBackground: DownColor = .init(red: 0.96, green: 0.97, blue: 0.98, alpha: 1))
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Code : BaseNode {
  public var literal: Swift.String? {
    get
  }
  @objc deinit
}
extension Code : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Paragraph : BaseNode {
  @objc deinit
}
extension Paragraph : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc final public class OGCacheData : ObjectiveC.NSObject {
  @nonobjc final public let ogData: OpenGraph.Data
  @objc final public let createDate: Foundation.Date?
  @objc final public let updateDate: Foundation.Date?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Document : BaseNode {
  @objc deinit
  @discardableResult
  public func accept<T>(_ visitor: T) -> T.Result where T : Visitor
}
extension Document : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class Localization : ObjectiveC.NSObject {
  @objc public class func localize(key: Swift.String, value: Swift.String) -> Swift.String
  @objc public class func localize(key: Swift.String) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public protocol DownXMLRenderable : DownRenderable {
  func toXML(_ options: DownOptions) throws -> Swift.String
}
extension DownXMLRenderable {
  public func toXML(_ options: DownOptions = .default) throws -> Swift.String
}
public struct DownXMLRenderer {
  public static func astToXML(_ ast: Swift.UnsafeMutablePointer<cmark_node>, options: DownOptions = .default) throws -> Swift.String
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: ((WebSocketError?) -> ())?)
  public func write(data: Foundation.Data, opcode: FrameOpCode, completion: ((WebSocketError?) -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol OGDataCacheManagerProtocol : ObjectiveC.NSObjectProtocol {
  @objc var updateInterval: Foundation.TimeInterval { get set }
  @objc func fetchOrInsertOGCacheData(url: Swift.String, completion: @escaping (OGCacheData) -> ())
  @objc func fetchOGCacheData(url: Swift.String, completion: @escaping (OGCacheData?) -> ())
  @objc func updateIfNeeded(cache: OGCacheData)
  @objc func deleteOGCacheDate(cache: OGCacheData, completion: ((Swift.Error?) -> Swift.Void)?)
}
public class WSCompression : CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
@objc @objcMembers public class PushUserInfo : ObjectiveC.NSObject {
  @objc final public let alert: Swift.String
  @objc final public let skillId: Swift.Int
  @objc final public let expiredAt: Swift.String
  @objc final public let chlSentAt: Swift.String
  @objc final public let campaign: Swift.String
  @objc final public let priority: Swift.Int
  @objc final public let senderName: Swift.String
  @objc final public let chatMessageId: Swift.String?
  @objc public init?(from pushUserInfo: [Swift.String : Any])
  @objc deinit
}
public struct DownOptions : Swift.OptionSet {
  public let rawValue: Swift.Int32
  public init(rawValue: Swift.Int32)
  public static var `default`: DownOptions
  public static var sourcePos: DownOptions
  public static var hardBreaks: DownOptions
  public static var safe: DownOptions
  public static var unsafe: DownOptions
  public static var normalize: DownOptions
  public static var validateUTF8: DownOptions
  public static var smart: DownOptions
  public static var smartUnsafe: DownOptions
  public typealias ArrayLiteralElement = DownOptions
  public typealias Element = DownOptions
  public typealias RawValue = Swift.Int32
}
@objc @_hasMissingDesignatedInitializers @objcMembers public class QuickReply : ObjectiveC.NSObject {
  @objc final public let text: Swift.String
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Heading : BaseNode {
  public var headingLevel: Swift.Int {
    get
  }
  @objc deinit
}
extension Heading : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: Frame)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ThreadsServerAPI : ObjectiveC.NSObject {
  public typealias Completion<T> = (T?, Swift.Error?) -> Swift.Void
  @objc public static var chatApiVersion: Swift.String
  public typealias HistoryCompletion = ThreadsServerAPI.Completion<Swift.Array<THRMessage>>
  public typealias MessagesReadCompletion = ThreadsServerAPI.Completion<Swift.Array<THRMessage>>
  @objc public static var isDebugLoggingEnabled: Swift.Bool
  @objc public static func setServer(baseUrl: Foundation.URL)
  @objc public static func markMessagesRead(_ messages: Swift.Array<THRMessage>, completion: @escaping ThreadsServerAPI.MessagesReadCompletion)
  @objc public static func getHistoryMessages(clientId: Swift.String, count: Swift.Int, beforeMessage: THRMessage?, completion: @escaping ThreadsServerAPI.HistoryCompletion)
  @objc override dynamic public init()
  @objc deinit
}
public struct ListItemOptions {
  public var maxPrefixDigits: Swift.UInt
  public var spacingAfterPrefix: CoreGraphics.CGFloat
  public var spacingAbove: CoreGraphics.CGFloat
  public var spacingBelow: CoreGraphics.CGFloat
  public init(maxPrefixDigits: Swift.UInt = 2, spacingAfterPrefix: CoreGraphics.CGFloat = 8, spacingAbove: CoreGraphics.CGFloat = 4, spacingBelow: CoreGraphics.CGFloat = 8)
}
public protocol Node {
  var cmarkNode: CMarkNode { get }
  var children: [Node] { get }
}
extension Node {
  public var hasSuccessor: Swift.Bool {
    get
  }
}
public typealias CMarkNode = Swift.UnsafeMutablePointer<cmark_node>
extension Swift.UnsafeMutablePointer where Pointee == cmark_node {
  public func wrap() -> Node?
  public var parent: CMarkNode? {
    get
  }
  public var type: cmark_node_type {
    get
  }
  public var literal: Swift.String? {
    get
  }
  public var fenceInfo: Swift.String? {
    get
  }
  public var headingLevel: Swift.Int {
    get
  }
  public var listType: cmark_list_type {
    get
  }
  public var listStart: Swift.Int {
    get
  }
  public var url: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
}
public struct QuoteStripeOptions {
  public var thickness: CoreGraphics.CGFloat
  public var spacingAfter: CoreGraphics.CGFloat
  public init(thickness: CoreGraphics.CGFloat = 2, spacingAfter: CoreGraphics.CGFloat = 8)
}
@objc @_inheritsConvenienceInitializers @objcMembers public class SocketConnectionError : ObjectiveC.NSObject {
  @objc public var error: Swift.Error?
  @objc public var stringError: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol SocketConnectionDelegate {
  @objc func didReceiveData(_ data: Foundation.Data)
  @objc func didConnected(_ isConnected: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @objcMembers public class SocketConnection : ObjectiveC.NSObject {
  @objc weak public var delegate: SocketConnectionDelegate?
  @objc public var autoReconnect: Swift.Bool {
    @objc get
    @objc set(value)
  }
  @objc public func connect(to url: Foundation.URL)
  @objc public func disconnect()
  @objc public func reconnect()
  @objc public func send(data: Foundation.Data, completion: ((SocketConnectionError?) -> ())?)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Emphasis : BaseNode {
  @objc deinit
}
extension Emphasis : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class WaitForNetwork : ObjectiveC.NSObject {
  public enum ConnectionType {
    case None
    case WiFi
    case Cellular
    public static func == (a: WaitForNetwork.ConnectionType, b: WaitForNetwork.ConnectionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
extension Swift.Double {
  public var minutes: Foundation.TimeInterval {
    get
  }
  public var hours: Foundation.TimeInterval {
    get
  }
  public var days: Foundation.TimeInterval {
    get
  }
  public var weeks: Foundation.TimeInterval {
    get
  }
  public var months: Foundation.TimeInterval {
    get
  }
  public var years: Foundation.TimeInterval {
    get
  }
}
extension Foundation.NSNumber {
  @objc dynamic public class func minutes(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func hours(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func days(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func weeks(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func months(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func years(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
}
@objc @_inheritsConvenienceInitializers public class DownLayoutManager : UIKit.NSLayoutManager {
  @objc override dynamic public func drawGlyphs(forGlyphRange glyphsToShow: Foundation.NSRange, at origin: CoreGraphics.CGPoint)
  @objc override dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class BaseNode : Node {
  final public let cmarkNode: CMarkNode
  public var children: [Node] {
    get
  }
  public var nestDepth: Swift.Int {
    get
  }
  @objc deinit
}
public protocol ParagraphStyleCollection {
  var heading1: UIKit.NSParagraphStyle { get set }
  var heading2: UIKit.NSParagraphStyle { get set }
  var heading3: UIKit.NSParagraphStyle { get set }
  var heading4: UIKit.NSParagraphStyle { get set }
  var heading5: UIKit.NSParagraphStyle { get set }
  var heading6: UIKit.NSParagraphStyle { get set }
  var body: UIKit.NSParagraphStyle { get set }
  var code: UIKit.NSParagraphStyle { get set }
}
public struct StaticParagraphStyleCollection : ParagraphStyleCollection {
  public var heading1: UIKit.NSParagraphStyle
  public var heading2: UIKit.NSParagraphStyle
  public var heading3: UIKit.NSParagraphStyle
  public var heading4: UIKit.NSParagraphStyle
  public var heading5: UIKit.NSParagraphStyle
  public var heading6: UIKit.NSParagraphStyle
  public var body: UIKit.NSParagraphStyle
  public var code: UIKit.NSParagraphStyle
  public init()
}
public protocol DownCommonMarkRenderable : DownRenderable {
  func toCommonMark(_ options: DownOptions, width: Swift.Int32) throws -> Swift.String
}
extension DownCommonMarkRenderable {
  public func toCommonMark(_ options: DownOptions = .default, width: Swift.Int32 = 0) throws -> Swift.String
}
public struct DownCommonMarkRenderer {
  public static func astToCommonMark(_ ast: Swift.UnsafeMutablePointer<cmark_node>, options: DownOptions = .default, width: Swift.Int32 = 0) throws -> Swift.String
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class HtmlBlock : BaseNode {
  public var literal: Swift.String? {
    get
  }
  @objc deinit
}
extension HtmlBlock : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Image : BaseNode {
  public var title: Swift.String? {
    get
  }
  public var url: Swift.String? {
    get
  }
  @objc deinit
}
extension Image : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  public func md5() -> Swift.String
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: FoundationSecurityError, b: FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension FoundationSecurity : CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((PinningState) -> ()))
}
extension FoundationSecurity : HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public protocol Styler {
  func style(document str: Foundation.NSMutableAttributedString)
  func style(blockQuote str: Foundation.NSMutableAttributedString, nestDepth: Swift.Int)
  func style(list str: Foundation.NSMutableAttributedString, nestDepth: Swift.Int)
  func style(listItemPrefix str: Foundation.NSMutableAttributedString)
  func style(item str: Foundation.NSMutableAttributedString, prefixLength: Swift.Int)
  func style(codeBlock str: Foundation.NSMutableAttributedString, fenceInfo: Swift.String?)
  func style(htmlBlock str: Foundation.NSMutableAttributedString)
  func style(customBlock str: Foundation.NSMutableAttributedString)
  func style(paragraph str: Foundation.NSMutableAttributedString)
  func style(heading str: Foundation.NSMutableAttributedString, level: Swift.Int)
  func style(thematicBreak str: Foundation.NSMutableAttributedString)
  func style(text str: Foundation.NSMutableAttributedString)
  func style(softBreak str: Foundation.NSMutableAttributedString)
  func style(lineBreak str: Foundation.NSMutableAttributedString)
  func style(code str: Foundation.NSMutableAttributedString)
  func style(htmlInline str: Foundation.NSMutableAttributedString)
  func style(customInline str: Foundation.NSMutableAttributedString)
  func style(emphasis str: Foundation.NSMutableAttributedString)
  func style(strong str: Foundation.NSMutableAttributedString)
  func style(link str: Foundation.NSMutableAttributedString, title: Swift.String?, url: Swift.String?)
  func style(image str: Foundation.NSMutableAttributedString, title: Swift.String?, url: Swift.String?)
}
public protocol DownAttributedStringRenderable : DownASTRenderable, DownHTMLRenderable {
  func toAttributedString(_ options: DownOptions, stylesheet: Swift.String?) throws -> Foundation.NSAttributedString
  func toAttributedString(_ options: DownOptions, styler: Styler) throws -> Foundation.NSAttributedString
}
extension DownAttributedStringRenderable {
  public func toAttributedString(_ options: DownOptions = .default, stylesheet: Swift.String? = nil) throws -> Foundation.NSAttributedString
  public func toAttributedString(_ options: DownOptions = .default, styler: Styler) throws -> Foundation.NSAttributedString
}
public class StringHTTPHandler : HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: HTTPHandlerDelegate)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class HtmlInline : BaseNode {
  public var literal: Swift.String? {
    get
  }
  @objc deinit
}
extension HtmlInline : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum URLEmbeddedViewError : Swift.Error {
  case invalidURLString(Swift.String)
}
public enum Result<T> {
  case success(T)
  case failure(Swift.Error)
  public var value: T? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class Task : ObjectiveC.NSObject {
  @objc deinit
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public var ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static var reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (Reachability) -> ()
  public typealias NetworkUnreachable = (Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable
    case reachableViaWiFi
    case reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: Reachability.NetworkStatus, b: Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    @available(*, deprecated, renamed: "unavailable")
    case none
    case unavailable
    case wifi
    case cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: Reachability.Connection, b: Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: Reachability.NetworkReachable?
  public var whenUnreachable: Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: Reachability.Connection {
    get
  }
  public var connection: Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  public convenience init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  public convenience init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public protocol DownRenderable {
  var markdownString: Swift.String { get set }
}
extension Foundation.URLRequest {
  public enum HTTPMethod : Swift.String {
    case GET
    case PUT
    case POST
    case DELETE
    case HEAD
    case OPTIONS
    case TRACE
    case CONNECT
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var method: Foundation.URLRequest.HTTPMethod? {
    get
    set(newValue)
  }
}
@objc @_inheritsConvenienceInitializers public class DownDebugLayoutManager : DownLayoutManager {
  @objc override dynamic public func drawGlyphs(forGlyphRange glyphsToShow: Foundation.NSRange, at origin: CoreGraphics.CGPoint)
  @objc override dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
open class DownStyler : Styler {
  final public let fonts: FontCollection
  final public let colors: ColorCollection
  final public let paragraphStyles: ParagraphStyleCollection
  final public let quoteStripeOptions: QuoteStripeOptions
  final public let thematicBreakOptions: ThematicBreakOptions
  final public let codeBlockOptions: CodeBlockOptions
  public init(configuration: DownStylerConfiguration = DownStylerConfiguration())
  open func style(document str: Foundation.NSMutableAttributedString)
  open func style(blockQuote str: Foundation.NSMutableAttributedString, nestDepth: Swift.Int)
  open func style(list str: Foundation.NSMutableAttributedString, nestDepth: Swift.Int)
  open func style(listItemPrefix str: Foundation.NSMutableAttributedString)
  open func style(item str: Foundation.NSMutableAttributedString, prefixLength: Swift.Int)
  open func style(codeBlock str: Foundation.NSMutableAttributedString, fenceInfo: Swift.String?)
  open func style(htmlBlock str: Foundation.NSMutableAttributedString)
  open func style(customBlock str: Foundation.NSMutableAttributedString)
  open func style(paragraph str: Foundation.NSMutableAttributedString)
  open func style(heading str: Foundation.NSMutableAttributedString, level: Swift.Int)
  open func style(thematicBreak str: Foundation.NSMutableAttributedString)
  open func style(text str: Foundation.NSMutableAttributedString)
  open func style(softBreak str: Foundation.NSMutableAttributedString)
  open func style(lineBreak str: Foundation.NSMutableAttributedString)
  open func style(code str: Foundation.NSMutableAttributedString)
  open func style(htmlInline str: Foundation.NSMutableAttributedString)
  open func style(customInline str: Foundation.NSMutableAttributedString)
  open func style(emphasis str: Foundation.NSMutableAttributedString)
  open func style(strong str: Foundation.NSMutableAttributedString)
  open func style(link str: Foundation.NSMutableAttributedString, title: Swift.String?, url: Swift.String?)
  open func style(image str: Foundation.NSMutableAttributedString, title: Swift.String?, url: Swift.String?)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class DownDebugTextView : DownTextView {
  @_Concurrency.MainActor(unsafe) public init(frame: CoreGraphics.CGRect, styler: Styler = DownStyler())
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias DownFontDescriptor = UIKit.UIFontDescriptor
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Text : BaseNode {
  public var literal: Swift.String? {
    get
  }
  @objc deinit
}
extension Text : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
