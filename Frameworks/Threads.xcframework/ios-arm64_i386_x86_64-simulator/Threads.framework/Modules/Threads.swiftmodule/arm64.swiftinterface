// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target arm64-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Threads
import CommonCrypto
import CoreData
import Foundation
import Foundation/*.Bundle*/
import Network
import Swift
import SystemConfiguration
@_exported import Threads
import UIKit
import WebKit
import _Concurrency
import os.log
import os
import zlib
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : Server, ConnectionDelegate {
  public var onEvent: ((ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
  public func didReceive(event: ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate, TransportEventClient {
  public var onEvent: ((ConnectionEvent) -> Swift.Void)?
  weak public var delegate: ConnectionDelegate?
  public func write(data: Foundation.Data, opcode: FrameOpCode)
  public func connectionChanged(state: ConnectionState)
  public func didReceive(event: HTTPEvent)
  public func frameProcessed(event: FrameEvent)
  public func didForm(event: FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: ErrorType, b: ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: ((WebSocketError?) -> Swift.Void)?)
  func write(stringData: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  func write(data: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  func write(ping: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  func write(pong: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: WebSocketEvent, client: WebSocketClient)
}
open class WebSocket : WebSocketClient, EngineDelegate {
  weak public var delegate: WebSocketDelegate?
  public var onEvent: ((WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set(newValue)
  }
  public init(request: Foundation.URLRequest, engine: Engine)
  public convenience init(request: Foundation.URLRequest, certPinner: CertificatePinning? = FoundationSecurity(), compressionHandler: CompressionHandler? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  public func write(string: Swift.String, completion: ((WebSocketError?) -> Swift.Void)?)
  public func write(stringData: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  public func write(ping: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  public func write(pong: Foundation.Data, completion: ((WebSocketError?) -> Swift.Void)?)
  public func didReceive(event: WebSocketEvent)
  @objc deinit
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: WebSocketEvent)
}
public protocol Engine {
  func register(delegate: EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: FrameOpCode, completion: ((WebSocketError?) -> Swift.Void)?)
  func write(string: Swift.String, completion: ((WebSocketError?) -> Swift.Void)?)
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((PinningState) -> Swift.Void))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
@objc @objcMembers public class LocalizationConfig : ObjectiveC.NSObject {
  @objc public init(bundle: Foundation.Bundle, tableName: Swift.String)
  @objc final public let bundle: Foundation.Bundle
  @objc final public let tableName: Swift.String
  @objc deinit
}
@objc @objcMembers public class THRClientInfo : ObjectiveC.NSObject {
  @objc public init(clientId: Swift.String)
  @objc final public let clientId: Swift.String
  @objc public var name: Swift.String?
  @objc public var data: Swift.String?
  @objc public var appMarker: Swift.String?
  @objc public var signature: Swift.String?
  @objc public var authToken: Swift.String?
  @objc public var authSchema: Swift.String?
  @objc deinit
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: ServerEvent)
}
public enum ServerEvent {
  case connected(Connection, [Swift.String : Swift.String])
  case disconnected(Connection, Swift.String, Swift.UInt16)
  case text(Connection, Swift.String)
  case binary(Connection, Foundation.Data)
  case pong(Connection, Foundation.Data?)
  case ping(Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: TCPTransportError, b: TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> Swift.Void))
  @objc deinit
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: FoundationTransportError, b: FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> Swift.Void))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(Frame)
  case error(Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: FramerEventClient)
  func createWriteFrame(opcode: FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: FramerEventClient)
  public func createWriteFrame(opcode: FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : MyWSArrayType {
}
extension Swift.Array where Element : Swift.UnsignedInteger, Element : MyWSArrayType {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : HTTPServerHandler {
  public func register(delegate: HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed(Swift.Error?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: CertificatePinning?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> Swift.Void))
  var usingTLS: Swift.Bool { get }
}
public enum WebSocketError {
  case unknownError
  case networkError(Swift.String)
  case compressionError(Swift.String)
  case securityError(Swift.String)
  case protocolError(Swift.String)
  case serverError(Swift.String)
  case anyError(Swift.Error?)
}
@objc @objcMembers public class THRRoutingParams : ObjectiveC.NSObject {
  @objc public init(priority: Swift.Int, skillId: Swift.Int, expiredAt: Swift.String?)
  @objc public func toDictionary() -> [Swift.String : Any]
  @objc deinit
}
public class WSEngine : Engine, TransportEventClient, FramerEventClient, FrameCollectorDelegate, HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: Transport, certPinner: CertificatePinning? = nil, headerValidator: HeaderValidator = FoundationSecurity(), httpHandler: HTTPHandler = FoundationHTTPHandler(), framer: Framer = WSFramer(), compressionHandler: CompressionHandler? = nil)
  public func register(delegate: EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: ((WebSocketError?) -> Swift.Void)?)
  public func write(data: Foundation.Data, opcode: FrameOpCode, completion: ((WebSocketError?) -> Swift.Void)?)
  public func connectionChanged(state: ConnectionState)
  public func didReceiveHTTP(event: HTTPEvent)
  public func frameProcessed(event: FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: FrameCollector.Event)
  @objc deinit
}
public class FoundationHTTPHandler : HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: HTTPHandlerDelegate)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class SocketSettings : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var resendIntervalSec: Swift.Double
  @objc public var resendPingIntervalSec: Swift.Double
  @objc public var connectTimeoutSec: Swift.Double
  @objc public var readTimeoutSec: Swift.Double
  @objc public var writeTimeoutSec: Swift.Double
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class HttpSettings : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var connectTimeoutSec: Swift.Double
  @objc public var downloadTimeoutSec: Swift.Double
  @objc public var uploadTimeoutSec: Swift.Double
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class THRRequestConfigs : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var socket: SocketSettings
  @objc public var http: HttpSettings
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class THRControls : ObjectiveC.NSObject {
  @objc final public var sendButton: UIKit.UIButton?
  @objc final public var attachButton: UIKit.UIButton?
  @objc override dynamic public init()
  @objc deinit
}
@objc(THRCert) final public class THRCert : ObjectiveC.NSObject {
  @objc public init(contentsOf url: Foundation.URL?)
  @objc public convenience init(contentsOfFile fileName: Swift.String)
  @objc deinit
}
@objc public protocol QuickReplyCellDelegate {
  @objc func didSelectQuickReply(_ quickReply: QuickReply)
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor(unsafe) public class QuickReplyCell : UIKit.UICollectionViewCell {
  @objc @_Concurrency.MainActor(unsafe) public class var sizingCell: QuickReplyCell {
    @objc get
  }
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) public var cellWidth: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) public var actionButton: UIKit.UIButton!
  @objc @_Concurrency.MainActor(unsafe) public class func cellIdentifier() -> Swift.String
  @objc @_Concurrency.MainActor(unsafe) public class func nib() -> UIKit.UINib
  @objc override dynamic public func awakeFromNib()
  @objc @_Concurrency.MainActor(unsafe) public func configure(quickReply: QuickReply, delegate: QuickReplyCellDelegate)
  @objc @_Concurrency.MainActor(unsafe) public func setWidth(_ width: CoreGraphics.CGFloat)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func prepareForReuse()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> URLParts?
}
@objc public protocol ThreadsPreloadView {
  @objc func startAnimation()
  @objc func stopAnimation()
  @objc func getView() -> UIKit.UIView!
}
@objc public enum THRMessageRecieveState : Swift.Int {
  case accepted
  case notAccepted
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol ThreadsDelegate {
  @objc func threads(_ threads: Threads, didReceiveError error: Swift.Error)
  @objc func threads(_ threads: Threads, unreadMessagesCount: Swift.UInt)
  @objc func threads(_ threads: Threads, didChangeDeviceAddress deviceAddress: Swift.String)
  @objc optional func threads(_ threads: Threads, allowOpenUrl: Foundation.URL) -> Swift.Bool
  @objc optional func customPreloadView() -> ThreadsPreloadView!
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class Threads : ObjectiveC.NSObject {
  @objc final public var isClientIdEncrypted: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public var isDebugLoggingEnabled: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public var isSocketAdditionalDebugLoggingEnabled: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public var registrationAtStartupDisable: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public var isShowsNetworkActivity: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public var clientId: Swift.String? {
    @objc get
  }
  @objc final public var clientName: Swift.String? {
    @objc get
  }
  @objc final public var appMarker: Swift.String? {
    @objc get
  }
  @objc final public var clientSignature: Swift.String? {
    @objc get
  }
  @objc final public var clientAuthToken: Swift.String? {
    @objc get
  }
  @objc final public var clientAuthSchema: Swift.String? {
    @objc get
  }
  @objc final public var isClientSet: Swift.Bool {
    @objc get
  }
  @objc final public var data: Swift.String? {
    @objc get
  }
  @objc final public var fileSizeLimit: Swift.Int {
    @objc get
  }
  @objc final public var attributes: THRAttributes {
    @objc get
  }
  @objc final public var controls: THRControls {
    @objc get
  }
  @objc final public var restURL: Foundation.URL? {
    @objc get
    @objc set(newValue)
  }
  @objc final public var dataStoreURL: Foundation.URL? {
    @objc get
    @objc set(newValue)
  }
  @objc final public var lastActivitySeconds: Foundation.TimeInterval {
    @objc get
  }
  @objc public static func threads() -> Threads
  @objc final public func configureTransportProtocol(with delegate: ThreadsDelegate?, webSocketURL: Foundation.URL, providerUid: Swift.String, restURL: Foundation.URL, dataStoreURL: Foundation.URL)
  @objc final public func registerApplicationForRemoteNotificationsStandartOptions(authorizationStatusDenied: (() -> Swift.Void)?, completionHandler: @escaping ((_ deviceToken: Foundation.Data?) -> Swift.Void))
  @objc final public func applicationDidRegisterForRemoteNotifications(withDeviceToken deviceToken: Foundation.Data)
  @objc final public func applicationDidFailToRegisterForRemoteNotificationsWithError(_ error: Swift.Error)
  @objc final public func applicationDidReceiveRemoteNotification(_ withUserInfo: [Swift.AnyHashable : Any])
  @objc final public func applicationDidReceiveRemoteNotification(_ withUserInfo: [Swift.AnyHashable : Any], fetchCompletionHandler _: (_ state: THRMessageRecieveState) -> Swift.Void)
  @objc final public func updateLocation(latitude: Foundation.NSNumber, longtitude: Foundation.NSNumber)
  @objc final public func setClientInfo(_ clientInfo: THRClientInfo)
  @objc final public func logout()
  @objc final public func logout(withClientId clientId: Swift.String)
  @objc final public func handlePushNotificationUserInfo(_ userInfo: [Swift.AnyHashable : Any])
  @objc final public func version() -> Foundation.NSString
  @objc final public func unreadMessagesCount() -> Swift.UInt
  @objc final public func clearCachedFiles()
  @objc final public func isThreadsOriginPushUserInfo(_ userInfo: [Swift.AnyHashable : Any]) -> Swift.Bool
  @objc final public func getAppMarker(fromPushUserInfo userInfo: [Swift.AnyHashable : Any]) -> Swift.String?
  @objc final public func sendMessage(withText: Swift.String, completion: ((_ error: Swift.Error?) -> Swift.Void)?)
  @objc final public func registerUser(with clientInfo: THRClientInfo, messageWithText text: Swift.String)
  @objc final public func sendMessage(with image: UIKit.UIImage, completion: ((_ error: Swift.Error?) -> Swift.Void)?)
  @objc final public func chatViewController(with attributes: THRAttributes) -> UIKit.UIViewController
  @objc final public func chatViewController(with attributes: THRAttributes, completionHandler: ((_ error: Swift.Error?) -> Swift.Void)?) -> UIKit.UIViewController
  @objc final public func chatViewController(with attributes: THRAttributes, pushUserInfo: [Swift.AnyHashable : Any], completionHandler: ((_ error: Swift.Error?) -> Swift.Void)?) -> UIKit.UIViewController
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class Localization : ObjectiveC.NSObject {
  @objc public class func localize(key: Swift.String, value: Swift.String) -> Swift.String
  @objc public class func localize(key: Swift.String) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: ((WebSocketError?) -> Swift.Void)?)
  public func write(data: Foundation.Data, opcode: FrameOpCode, completion: ((WebSocketError?) -> Swift.Void)?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
public class WSCompression : CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
@objc @objcMembers public class PushUserInfo : ObjectiveC.NSObject {
  @objc public init?(from pushUserInfo: [Swift.String : Any])
  @objc final public let alert: Swift.String
  @objc final public let skillId: Swift.Int
  @objc final public let expiredAt: Swift.String
  @objc final public let chlSentAt: Swift.String
  @objc final public let campaign: Swift.String
  @objc final public let priority: Swift.Int
  @objc final public let senderName: Swift.String
  @objc final public let chatMessageId: Swift.String?
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers public class QuickReply : ObjectiveC.NSObject {
  @objc final public let text: Swift.String
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: Frame)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class THRColor : ObjectiveC.NSObject {
  @objc public static func color(by name: Swift.String, colorType: THRSysColor) -> UIKit.UIColor
  @objc public static func color(by name: Swift.String, defColor: UIKit.UIColor) -> UIKit.UIColor
  @objc public static func color(by sysColor: THRSysColor) -> UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum THRSysColor : Swift.Int {
  case darkGreen
  case lightGreen
  case gray
  case lightGray
  case middleGray
  case darkGray
  case darkerGray
  case blackTransparent50
  case lightCyan
  case blue
  case red
  case orange
  case darkOrange
  case gold
  case label
  case secondaryLabel
  case tertiaryLabel
  case quaternaryLabel
  case systemFill
  case secondarySystemFill
  case tertiarySystemFill
  case quaternarySystemFill
  case placeholderText
  case systemBackground
  case secondarySystemBackground
  case tertiarySystemBackground
  case systemGroupedBackground
  case secondarySystemGroupedBackground
  case tertiarySystemGroupedBackground
  case separator
  case opaqueSeparator
  case link
  case darkText
  case lightText
  case systemBlue
  case systemGreen
  case systemIndigo
  case systemOrange
  case systemPink
  case systemPurple
  case systemRed
  case systemTeal
  case systemYellow
  case systemGray
  case systemGray2
  case systemGray3
  case systemGray4
  case systemGray5
  case systemGray6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum THRQuickReplyPresentationMode : Swift.UInt {
  case toolbar
  case embed
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers public class THRAttributes : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var canShowDebugScreen: Swift.Bool
  @objc public var localizationConfig: LocalizationConfig?
  @objc public var statusBarStyle: UIKit.UIStatusBarStyle
  @objc public var refreshColor: UIKit.UIColor
  @objc public var navigationBarVisible: Swift.Bool
  @objc public var navigationBarCustomizeTitle: Swift.Bool
  @objc public var navigationBarTitle: Swift.String?
  @objc public var navigationBarTitleColor: UIKit.UIColor
  @objc public var navigationBarTitleFont: UIKit.UIFont
  @objc public var navigationBarSubtitleFont: UIKit.UIFont
  @objc public var navigationBarSubtitleColor: UIKit.UIColor
  @objc public var navigationBarSubtitleShowOrgUnit: Swift.Bool
  @objc public var navigationBarSubtitleVisible: Swift.Bool
  @objc public var navigationBarLarge: Swift.Bool
  @objc public var navigationBarKeyboardControlVisible: Swift.Bool
  @objc public var navigationBarKeyboardShowImage: UIKit.UIImage?
  @objc public var navigationBarKeyboardHideImage: UIKit.UIImage?
  @objc public var launchViewEnable: Swift.Bool
  @objc public var launchActivityViewColor: UIKit.UIColor
  @objc public var launchViewBackgroundColor: UIKit.UIColor
  @objc public var launchViewInnerBoxBackgroundColor: UIKit.UIColor
  @objc public var launchViewInnerBoxCornerRadius: CoreGraphics.CGFloat
  @objc public var launchViewInnerBoxSize: CoreGraphics.CGSize
  @objc public var launchViewTextColor: UIKit.UIColor
  @objc public var launchViewTextFont: UIKit.UIFont
  @objc public var backgroundColor: UIKit.UIColor
  @objc public var placeholderImage: UIKit.UIImage?
  @objc public var placeholderTitleColor: UIKit.UIColor
  @objc public var placeholderSubtitleColor: UIKit.UIColor
  @objc public var placeholderTitleFont: UIKit.UIFont
  @objc public var placeholderSubtitleFont: UIKit.UIFont
  @objc public var toolbarbackgroundColor: UIKit.UIColor
  @objc public var toolbarTintColor: UIKit.UIColor
  @objc public var attachButtonImage: UIKit.UIImage?
  @objc public var attachButtonColor: UIKit.UIColor
  @objc public var attachButtonHighlightColor: UIKit.UIColor
  @objc public var showAttachButton: Swift.Bool
  @objc public var sendButtonColor: UIKit.UIColor
  @objc public var sendButtonHighlightColor: UIKit.UIColor
  @objc public var sendButtonDisabledColor: UIKit.UIColor
  @objc public var sendButtonFont: UIKit.UIFont
  @objc public var sendButtonImage: UIKit.UIImage?
  @objc public var myMessageFont: UIKit.UIFont
  @objc public var toolbarQuotedMessageAuthorFont: UIKit.UIFont
  @objc public var toolbarQuotedMessageFont: UIKit.UIFont
  @objc public var toolbarQuotedMessageAuthorColor: UIKit.UIColor
  @objc public var toolbarQuotedMessageColor: UIKit.UIColor
  @objc public var toolbarInputHasBorder: Swift.Bool
  @objc public var toolbarInputCornerRadius: CoreGraphics.CGFloat
  @objc public var toolbarInputMinimumHeight: CoreGraphics.CGFloat
  @objc public var toolbarInputMaximumHeight: CoreGraphics.CGFloat
  @objc public var toolbarInputTextColor: UIKit.UIColor
  @objc public var toolbarInputCursorColor: UIKit.UIColor
  @objc public var toolbarInputBackgroundColor: UIKit.UIColor
  @objc public var showWaitingForSpecialistProgress: Swift.Bool
  @objc public var waitingSpecialistSpinnerColor: UIKit.UIColor
  @objc public var waitingSpecialistBgColor: UIKit.UIColor
  @objc public var waitingSpecialistBorderColor: UIKit.UIColor
  @objc public var waitingSpecialistBorderWidth: CoreGraphics.CGFloat
  @objc public var bubbleMessageFont: UIKit.UIFont
  @objc public var bubbleTimeFont: UIKit.UIFont
  @objc public var failedMessageFont: UIKit.UIFont
  @objc public var messageHeaderFont: UIKit.UIFont
  @objc public var quoteAuthorFont: UIKit.UIFont
  @objc public var quoteMessageFont: UIKit.UIFont
  @objc public var quoteTimeFont: UIKit.UIFont
  @objc public var quoteFilesizeFont: UIKit.UIFont
  @objc public var messageBubbleFilledMaskImage: UIKit.UIImage?
  @objc public var messageBubbleStrokedMaskImage: UIKit.UIImage?
  @objc public var messageBubbleFilledMaskInsets: UIKit.UIEdgeInsets
  @objc public var messageBubbleStrokedMaskInsets: UIKit.UIEdgeInsets
  @objc public var messageContainerRightOffset: CoreGraphics.CGFloat
  @objc public var messageContainerLeftOffset: CoreGraphics.CGFloat
  @objc public var messageBubbleTextViewFrameInsets: UIKit.UIEdgeInsets
  @objc public var messageBubbleTextViewTextContainerInsets: UIKit.UIEdgeInsets
  @objc public var messageBubbleOppositeMargin: CoreGraphics.CGFloat
  @objc public var emptyImageColor: UIKit.UIColor
  @objc public var timeAndStatusBackgroundColor: UIKit.UIColor
  @objc public var specialisConnectTitleFont: UIKit.UIFont
  @objc public var specialisConnectSubtitleFont: UIKit.UIFont
  @objc public var specialisConnectTitleColor: UIKit.UIColor
  @objc public var specialisConnectSubtitleColor: UIKit.UIColor
  @objc public var typingTextFont: UIKit.UIFont
  @objc public var typingTextColor: UIKit.UIColor
  @objc public var typingText: Swift.String?
  @objc public var typingIndicatorEllipsisColor: UIKit.UIColor?
  @objc public var scheduleIcon: UIKit.UIImage?
  @objc public var scheduleAlertColor: UIKit.UIColor
  @objc public var scheduleAlertFont: UIKit.UIFont
  @objc public var scheduleIconBackgroundColor: UIKit.UIColor
  @objc public var scrollToBottomImage: UIKit.UIImage?
  @objc public var scrollToBottomBadgeColor: UIKit.UIColor
  @objc public var scrollToBottomBadgeTextColor: UIKit.UIColor
  @objc public var incomingBubbleStroked: Swift.Bool
  @objc public var incomingBubbleColor: UIKit.UIColor
  @objc public var incomingBubbleTextColor: UIKit.UIColor
  @objc public var incomingBubbleLinkColor: UIKit.UIColor
  @objc public var incomingTimeColor: UIKit.UIColor
  @objc public var showIncomingAvatar: Swift.Bool
  @objc public var incomingQuoteSeparatorColor: UIKit.UIColor
  @objc public var incomingQuoteAuthorColor: UIKit.UIColor
  @objc public var incomingQuoteMessageColor: UIKit.UIColor
  @objc public var incomingQuoteTimeColor: UIKit.UIColor
  @objc public var incomingQuoteFilesizeColor: UIKit.UIColor
  @objc public var incomingFileIconTintColor: UIKit.UIColor
  @objc public var incomingFileIconBgColor: UIKit.UIColor
  @objc public var incomingMediaTimeColor: UIKit.UIColor
  @objc public var commonMessageAvatarSize: CoreGraphics.CGFloat
  @objc public var systemMessageAvatarSize: CoreGraphics.CGFloat
  @objc public var failedBubbleStroked: Swift.Bool
  @objc public var failedBubbleColor: UIKit.UIColor
  @objc public var outgoingBubbleStroked: Swift.Bool
  @objc public var outgoingBubbleColor: UIKit.UIColor
  @objc public var outgoingBubbleTextColor: UIKit.UIColor
  @objc public var outgoingBubbleLinkColor: UIKit.UIColor
  @objc public var outgoingTimeColor: UIKit.UIColor
  @objc public var outgoingPendingStatusColor: UIKit.UIColor
  @objc public var outgoingDeliveredStatusColor: UIKit.UIColor
  @objc public var outgoingReadStatusColor: UIKit.UIColor
  @objc public var outgoingPendingStatusImage: UIKit.UIImage?
  @objc public var outgoingDeliveredStatusImage: UIKit.UIImage?
  @objc public var outgoingReadStatusImage: UIKit.UIImage?
  @objc public var showOutgoingAvatar: Swift.Bool
  @objc public var avatarPlaceholderImage: UIKit.UIImage?
  @objc public var outgoingQuoteSeparatorColor: UIKit.UIColor
  @objc public var outgoingQuoteAuthorColor: UIKit.UIColor
  @objc public var outgoingQuoteMessageColor: UIKit.UIColor
  @objc public var outgoingQuoteTimeColor: UIKit.UIColor
  @objc public var outgoingQuoteFilesizeColor: UIKit.UIColor
  @objc public var outgoingFileIconTintColor: UIKit.UIColor
  @objc public var outgoingFileIconBgColor: UIKit.UIColor
  @objc public var outgoingMediaTimeColor: UIKit.UIColor
  @objc public var outgoingMediaPendingStatusColor: UIKit.UIColor
  @objc public var outgoingMediaDeliveredStatusColor: UIKit.UIColor
  @objc public var outgoingMediaReadStatusColor: UIKit.UIColor
  @objc public var searchScopeBarTintColor: UIKit.UIColor
  @objc public var searchBarTextColor: UIKit.UIColor
  @objc public var searchBarTintColor: UIKit.UIColor
  @objc public var searchScopeBarFont: UIKit.UIFont
  @objc public var searchBarTextFont: UIKit.UIFont
  @objc public var searchIconDisabled: Swift.Bool
  @objc public var clearSearchIcon: UIKit.UIImage?
  @objc public var findedMessageHeaderTextColor: UIKit.UIColor
  @objc public var findedMessageHeaderBackgroundColor: UIKit.UIColor
  @objc public var findedMessageHeaderTextFont: UIKit.UIFont
  @objc public var findMoreMessageTextColor: UIKit.UIColor
  @objc public var findMoreMessageTextFont: UIKit.UIFont
  @objc public var searchMessageAuthorTextColor: UIKit.UIColor
  @objc public var searchMessageTextColor: UIKit.UIColor
  @objc public var searchMessageDateTextColor: UIKit.UIColor
  @objc public var searchMessageFileTextColor: UIKit.UIColor
  @objc public var searchMessageMatchTextColor: UIKit.UIColor
  @objc public var searchMessageAuthorTextFont: UIKit.UIFont
  @objc public var searchMessageMatchTextFont: UIKit.UIFont
  @objc public var searchMessageTextFont: UIKit.UIFont
  @objc public var searchMessageFileTextFont: UIKit.UIFont
  @objc public var searchMessageDateTextFont: UIKit.UIFont
  @objc public var photoPickerSelfieEnabled: Swift.Bool
  @objc public var photoPickerToolbarTintColor: UIKit.UIColor
  @objc public var photoPickerToolbarButtonFont: UIKit.UIFont
  @objc public var photoPickerCheckmarkIcon: UIKit.UIImage?
  @objc public var photoPickerEmptyCheckmarkIcon: UIKit.UIImage?
  @objc public var photoPickerSheetTextColor: UIKit.UIColor
  @objc public var photoPickerSheetTextFont: UIKit.UIFont
  @objc public var fileViewerTitleColor: UIKit.UIColor?
  @objc public var fileViewerNavBarBackgroundColor: UIKit.UIColor?
  @objc public var fileViewerNavBarTintColor: UIKit.UIColor?
  @objc public var fileViewerBackgroundColor: UIKit.UIColor
  @objc public var fileViewerTitleFont: UIKit.UIFont
  @objc public var canShowSpecialistInfo: Swift.Bool
  @objc public var starRatingColorEnabled: UIKit.UIColor
  @objc public var likeRatingColorEnabled: UIKit.UIColor
  @objc public var starRatingColorDisabled: UIKit.UIColor
  @objc public var likeRatingColorDisabled: UIKit.UIColor
  @objc public var starRatingColorCompleted: UIKit.UIColor
  @objc public var likeRatingColorCompleted: UIKit.UIColor
  @objc public var likeLabelOnStarColor: UIKit.UIColor
  @objc public var likeLabelUnderStarColor: UIKit.UIColor
  @objc public var surveyTextColor: UIKit.UIColor
  @objc public var surveyTextFont: UIKit.UIFont
  @objc public var surveyCompletionColor: UIKit.UIColor
  @objc public var surveyCompletionFont: UIKit.UIFont
  @objc public var surveyCompletionDelay: Swift.Int
  @objc public var iconStarRatingEmty: UIKit.UIImage?
  @objc public var iconStarRatingFull: UIKit.UIImage?
  @objc public var iconLikeEmpty: UIKit.UIImage?
  @objc public var iconDislikeEmpty: UIKit.UIImage?
  @objc public var iconLikeFull: UIKit.UIImage?
  @objc public var iconDislikeFull: UIKit.UIImage?
  @objc public var quickReplyPresentationMode: THRQuickReplyPresentationMode
  @objc public var quickReplyFont: UIKit.UIFont
  @objc public var quickReplyBorderCornerRadius: Foundation.NSNumber
  @objc public var quickReplyBorderColor: UIKit.UIColor
  @objc public var quickReplyBackgroundColor: UIKit.UIColor
  @objc public var quickReplyTextColor: UIKit.UIColor
  @objc public var quickReplyBackgroundColorHighlighted: UIKit.UIColor
  @objc public var quickReplyTextColorHighLighted: UIKit.UIColor
  @objc public var quickReplyButtonHeight: CoreGraphics.CGFloat
  @objc public var quickReplyBorderWidth: CoreGraphics.CGFloat
  @objc public var voiceRecordingAllowed: Swift.Bool
  @objc public var voiceMessageRecordButtonImage: UIKit.UIImage?
  @objc public var voiceMessageSendButtonImage: UIKit.UIImage?
  @objc public var voiceMessageRecordSendButtonColor: UIKit.UIColor
  @objc public var voiceMessagePlayImage: UIKit.UIImage?
  @objc public var voiceMessagePauseImage: UIKit.UIImage?
  @objc public var incomingVoiceMessagePlayPauseColor: UIKit.UIColor
  @objc public var outgoingVoiceMessagePlayPauseColor: UIKit.UIColor
  @objc public var previewVoiceMessagePlayPauseColor: UIKit.UIColor
  @objc public var incomingVoiceMessageProgressColor: UIKit.UIColor
  @objc public var outgoingVoiceMessageProgressColor: UIKit.UIColor
  @objc public var previewVoiceMessageProgressColor: UIKit.UIColor
  @objc public var showCloseButton: Swift.Bool
  @objc public var closeButtonColor: UIKit.UIColor?
  @objc public var closeButtonImage: UIKit.UIImage?
  @objc public var newChatCenterApi: Swift.Bool
  @objc public var customHTTPHeadersForDataStore: [Swift.String : Swift.String]?
  @objc public var historyLoadingCount: Foundation.NSNumber
  @objc public var callReceiveResponseEnabled: Swift.Bool
  @objc public var clearChatHistoryIfSocketReconnect: Swift.Bool
  @objc public var allowUntrustedSSLCertificate: Swift.Bool
  @objc public var trustedCertificates: [THRCert]
  @objc public var photoPickerMaxImagesCount: Swift.UInt {
    @objc get
    @objc set(newValue)
  }
  @objc public static func defaultAttributes() -> THRAttributes
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class WaitForNetwork : ObjectiveC.NSObject {
  @objc deinit
  public enum ConnectionType {
    case unavailable
    case wiFi
    case cellular
    public static func == (a: WaitForNetwork.ConnectionType, b: WaitForNetwork.ConnectionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Swift.Double {
  public var minutes: Foundation.TimeInterval {
    get
  }
  public var hours: Foundation.TimeInterval {
    get
  }
  public var days: Foundation.TimeInterval {
    get
  }
  public var weeks: Foundation.TimeInterval {
    get
  }
  public var months: Foundation.TimeInterval {
    get
  }
  public var years: Foundation.TimeInterval {
    get
  }
}
extension Foundation.NSNumber {
  @objc dynamic public class func minutes(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func hours(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func days(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func weeks(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func months(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
  @objc dynamic public class func years(_ time: Foundation.TimeInterval) -> Foundation.TimeInterval
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
@objc(THRMessageRecieveStateOld) public enum THRMessageRecieveStateOld : Swift.Int {
  case accepted
  case notAccepted
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class THRMessageInfo : ObjectiveC.NSObject {
  @objc public init(text: Swift.String?, senderName: Swift.String, hasAttachment: Swift.Bool)
  final public let senderName: Swift.String
  final public let text: Swift.String?
  final public let hasAttachment: Swift.Bool
  @objc deinit
}
extension Swift.String {
  public func md5() -> Swift.String
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: FoundationSecurityError, b: FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension FoundationSecurity : CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((PinningState) -> Swift.Void))
}
extension FoundationSecurity : HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public class StringHTTPHandler : HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: HTTPHandlerDelegate)
  @objc deinit
}
public enum URLEmbeddedViewError : Swift.Error {
  case invalidURLString(Swift.String)
}
public enum Result<T> {
  case success(T)
  case failure(Swift.Error)
  public var value: T? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public var ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static var reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  public convenience init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  public convenience init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
  public typealias NetworkReachable = (Reachability) -> Swift.Void
  public typealias NetworkUnreachable = (Reachability) -> Swift.Void
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable
    case reachableViaWiFi
    case reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: Reachability.NetworkStatus, b: Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    @available(*, deprecated, renamed: "unavailable")
    case none
    case unavailable
    case wifi
    case cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: Reachability.Connection, b: Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: Reachability.NetworkReachable?
  public var whenUnreachable: Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: Reachability.Connection {
    get
  }
  public var connection: Reachability.Connection {
    get
  }
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Foundation.URLRequest {
  public enum HTTPMethod : Swift.String {
    case GET
    case PUT
    case POST
    case DELETE
    case HEAD
    case OPTIONS
    case TRACE
    case CONNECT
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var method: Foundation.URLRequest.HTTPMethod? {
    get
    set(newValue)
  }
}
